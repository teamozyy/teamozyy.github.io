<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>spring boot多数据源——AOP动态数据源</title>
    <url>/2019/12/01/spring-boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E2%80%94%E2%80%94AOP%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>上一节介绍了分包方式实现的多数据源配置方式，相比分包，AOP配置多数据源更加灵活，而且也不会有多数据源带来的事务问题</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h4 id="application配置文件"><a href="#application配置文件" class="headerlink" title="application配置文件"></a>application配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  datasource:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    master: # 主数据源</span></pre></td></tr><tr><td class="code"><pre><span class="line">      driver-class-name: com.mysql.cj.jdbc.Driver</span></pre></td></tr><tr><td class="code"><pre><span class="line">      url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test_01?useUnicode&#x3D;true&amp;useSSL&#x3D;false&amp;characterEncoding&#x3D;utf8&amp;serverTimezone&#x3D;GMT%2B8</span></pre></td></tr><tr><td class="code"><pre><span class="line">      username: root</span></pre></td></tr><tr><td class="code"><pre><span class="line">      password: 123123</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cluster: # 其他数据源，可定义多个</span></pre></td></tr><tr><td class="code"><pre><span class="line">    - key: assesssystem</span></pre></td></tr><tr><td class="code"><pre><span class="line">      driver-class-name: com.mysql.cj.jdbc.Driver</span></pre></td></tr><tr><td class="code"><pre><span class="line">      url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;assesssystem?useUnicode&#x3D;true&amp;useSSL&#x3D;false&amp;characterEncoding&#x3D;utf8&amp;serverTimezone&#x3D;GMT%2B8</span></pre></td></tr><tr><td class="code"><pre><span class="line">      username: root</span></pre></td></tr><tr><td class="code"><pre><span class="line">      password: 123123</span></pre></td></tr></table></figure>

<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>使用注解的方式实现动态数据源的切换，这样可以保证其灵活性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE, ElementType.PARAMETER&#125;) &#x2F;&#x2F; 用于描述类，方法和接口</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)  &#x2F;&#x2F; 注解生命周期，RUNTIME是运行级别保留，在编译后的class文件中存在，在jvm运行时保留</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Documented  &#x2F;&#x2F; 用于标识，可以被javadoc工具文档化</span></pre></td></tr><tr><td class="code"><pre><span class="line">public @interface DataSource &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    String value() default &quot;master&quot;; &#x2F;&#x2F; 默认为master数据源</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="对数据源进行管理"><a href="#对数据源进行管理" class="headerlink" title="对数据源进行管理"></a>对数据源进行管理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class DynamicDataSourceContextHolder &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 存储已经注册的数据源的key</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static List&lt;String&gt; dataSourceIds &#x3D; new ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 线程级别的私有变量</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private static final ThreadLocal&lt;String&gt; HOLDER &#x3D; new ThreadLocal&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static String getDataSourceRouterKey () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return HOLDER.get();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void setDataSourceRouterKey (String dataSourceRouterKey) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.info(&quot;切换至&#123;&#125;数据源&quot;, dataSourceRouterKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        HOLDER.set(dataSourceRouterKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 设置数据源之前一定要先移除</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void removeDataSourceRouterKey () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        HOLDER.remove();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 判断指定DataSrouce当前是否存在</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @param dataSourceId</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @return</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static boolean containsDataSource(String dataSourceId)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return dataSourceIds.contains(dataSourceId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="注册数据源"><a href="#注册数据源" class="headerlink" title="注册数据源"></a>注册数据源</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class DynamicDataSourceRegister implements ImportBeanDefinitionRegistrar, EnvironmentAware &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 配置上下文（也可以理解为配置文件的获取工具）</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Environment evn;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 别名</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private final static ConfigurationPropertyNameAliases aliases &#x3D; new ConfigurationPropertyNameAliases();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 由于部分数据源配置不同，所以在此处添加别名，避免切换数据源出现某些参数无法注入的情况</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    static &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        aliases.addAliases(&quot;url&quot;, new String[]&#123;&quot;jdbc-url&quot;&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        aliases.addAliases(&quot;username&quot;, new String[]&#123;&quot;user&quot;&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 存储我们注册的数据源</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Map&lt;String, DataSource&gt; customDataSources &#x3D; new HashMap&lt;String, DataSource&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 参数绑定工具 springboot2.0新推出</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Binder binder;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * ImportBeanDefinitionRegistrar接口的实现方法，通过该方法可以按照自己的方式注册bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @param annotationMetadata</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @param beanDefinitionRegistry</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 获取所有数据源配置</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map config, defauleDataSourceProperties;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        defauleDataSourceProperties &#x3D; binder.bind(&quot;spring.datasource.master&quot;, Map.class).get();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 获取数据源类型</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String typeStr &#x3D; evn.getProperty(&quot;spring.datasource.master.type&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 获取数据源类型</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class&lt;? extends DataSource&gt; clazz &#x3D; getDataSourceType(typeStr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 绑定默认数据源参数 也就是主数据源</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DataSource consumerDatasource, defaultDatasource &#x3D; bind(clazz, defauleDataSourceProperties);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DynamicDataSourceContextHolder.dataSourceIds.add(&quot;master&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.info(&quot;注册默认数据源成功&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 获取其他数据源配置</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Map&gt; configs &#x3D; binder.bind(&quot;spring.datasource.cluster&quot;, Bindable.listOf(Map.class)).get();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 遍历从数据源</span></pre></td></tr><tr><td class="code"><pre><span class="line">        for (int i &#x3D; 0; i &lt; configs.size(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            config &#x3D; configs.get(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            clazz &#x3D; getDataSourceType((String) config.get(&quot;type&quot;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            defauleDataSourceProperties &#x3D; config;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F; 绑定参数</span></pre></td></tr><tr><td class="code"><pre><span class="line">            consumerDatasource &#x3D; bind(clazz, defauleDataSourceProperties);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F; 获取数据源的key，以便通过该key可以定位到数据源</span></pre></td></tr><tr><td class="code"><pre><span class="line">            String key &#x3D; config.get(&quot;key&quot;).toString();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            customDataSources.put(key, consumerDatasource);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F; 数据源上下文，用于管理数据源与记录已经注册的数据源key</span></pre></td></tr><tr><td class="code"><pre><span class="line">            DynamicDataSourceContextHolder.dataSourceIds.add(key);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            log.info(&quot;注册数据源&#123;&#125;成功&quot;, key);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; bean定义类</span></pre></td></tr><tr><td class="code"><pre><span class="line">        GenericBeanDefinition define &#x3D; new GenericBeanDefinition();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 设置bean的类型，此处DynamicRoutingDataSource是继承AbstractRoutingDataSource的实现类</span></pre></td></tr><tr><td class="code"><pre><span class="line">        define.setBeanClass(DynamicRoutingDataSource.class);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 需要注入的参数</span></pre></td></tr><tr><td class="code"><pre><span class="line">        MutablePropertyValues mpv &#x3D; define.getPropertyValues();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 添加默认数据源，避免key不存在的情况没有数据源可用</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mpv.add(&quot;defaultTargetDataSource&quot;, defaultDatasource);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 添加其他数据源</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mpv.add(&quot;targetDataSources&quot;, customDataSources);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 将该bean注册为datasource，不使用springboot自动生成的datasource</span></pre></td></tr><tr><td class="code"><pre><span class="line">        beanDefinitionRegistry.registerBeanDefinition(&quot;datasource&quot;, define);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.info(&quot;注册数据源成功，一共注册&#123;&#125;个数据源&quot;, customDataSources.keySet().size() + 1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 通过字符串获取数据源class对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @param typeStr</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @return</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Class&lt;? extends DataSource&gt; getDataSourceType(String typeStr) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class&lt;? extends DataSource&gt; type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if (StringUtils.hasLength(typeStr)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#x2F;&#x2F; 字符串不为空则通过反射获取class对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">                type &#x3D; (Class&lt;? extends DataSource&gt;) Class.forName(typeStr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#x2F;&#x2F; 默认为hikariCP数据源，与springboot默认数据源保持一致</span></pre></td></tr><tr><td class="code"><pre><span class="line">                type &#x3D; HikariDataSource.class;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; catch (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F;无法通过反射获取class对象的情况则抛出异常，该情况一般是写错了，所以此次抛出一个runtimeexception</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw new IllegalArgumentException(&quot;can not resolve class with type: &quot; + typeStr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 绑定参数，以下三个方法都是参考DataSourceBuilder的bind方法实现的，目的是尽量保证我们自己添加的数据源构造过程与springboot保持一致</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @param result</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @param properties</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private void bind(DataSource result, Map properties) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ConfigurationPropertySource source &#x3D; new MapConfigurationPropertySource(properties);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Binder binder &#x3D; new Binder(new ConfigurationPropertySource[]&#123;source.withAliases(aliases)&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 将参数绑定到对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">        binder.bind(ConfigurationPropertyName.EMPTY, Bindable.ofInstance(result));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private &lt;T extends DataSource&gt; T bind(Class&lt;T&gt; clazz, Map properties) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ConfigurationPropertySource source &#x3D; new MapConfigurationPropertySource(properties);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Binder binder &#x3D; new Binder(new ConfigurationPropertySource[]&#123;source.withAliases(aliases)&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 通过类型绑定参数并获得实例对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return binder.bind(ConfigurationPropertyName.EMPTY, Bindable.of(clazz)).get();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @param clazz</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @param sourcePath 参数路径，对应配置文件中的值，如: spring.datasource</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @param &lt;T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @return</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private &lt;T extends DataSource&gt; T bind(Class&lt;T&gt; clazz, String sourcePath) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map properties &#x3D; binder.bind(sourcePath, Map.class).get();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return bind(clazz, properties);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * EnvironmentAware接口的实现方法，通过aware的方式注入，此处是environment对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @param environment</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void setEnvironment(Environment environment) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.info(&quot;开始注册数据源&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.evn &#x3D; environment;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 绑定配置器</span></pre></td></tr><tr><td class="code"><pre><span class="line">        binder &#x3D; Binder.get(evn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="缓存自定义注解的值"><a href="#缓存自定义注解的值" class="headerlink" title="缓存自定义注解的值"></a>缓存自定义注解的值</h4><p>创建工具类来获取注解中的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class DynamicDataSourceAnnotationInterceptor implements MethodInterceptor &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 缓存方法注解值</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private static final Map&lt;Method, String&gt; METHOD_CACHE &#x3D; new HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#x2F;&#x2F; 获取数据源名称</span></pre></td></tr><tr><td class="code"><pre><span class="line">            String datasource &#x3D; determineDatasource(invocation);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F; 若数据源不存在，则使用默认数据源master</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if (! DynamicDataSourceContextHolder.containsDataSource(datasource)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                log.info(&quot;数据源[&#123;&#125;]不存在，使用默认数据源 &gt;&quot;, datasource);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F; 否则使用数据源</span></pre></td></tr><tr><td class="code"><pre><span class="line">            DynamicDataSourceContextHolder.setDataSourceRouterKey(datasource);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return invocation.proceed();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; finally &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            DynamicDataSourceContextHolder.removeDataSourceRouterKey();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String determineDatasource(MethodInvocation invocation) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#x2F;&#x2F; 获取注解方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Method method &#x3D; invocation.getMethod();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 若方法在Map中已存在</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (METHOD_CACHE.containsKey(method)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#x2F;&#x2F; 返回该方法对应的数据源名称</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return METHOD_CACHE.get(method);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#x2F;&#x2F; 否则获取该方法注解的内容(数据源名称)存入Map中</span></pre></td></tr><tr><td class="code"><pre><span class="line">            DataSource ds &#x3D; method.isAnnotationPresent(DataSource.class) ? method.getAnnotation(DataSource.class)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    : AnnotationUtils.findAnnotation(method.getDeclaringClass(), DataSource.class);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            METHOD_CACHE.put(method, ds.value());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return ds.value();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="AOP织入数据源"><a href="#AOP织入数据源" class="headerlink" title="AOP织入数据源"></a>AOP织入数据源</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DynamicDataSourceAnnotationAdvisor extends AbstractPointcutAdvisor implements BeanFactoryAware &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Advice advice;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Pointcut pointcut;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public DynamicDataSourceAnnotationAdvisor(DynamicDataSourceAnnotationInterceptor dynamicDataSourceAnnotationInterceptor) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.advice &#x3D; dynamicDataSourceAnnotationInterceptor;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this.pointcut &#x3D; buildPointcut();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Pointcut getPointcut() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return this.pointcut;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Advice getAdvice() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return this.advice;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (this.advice instanceof BeanFactoryAware) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((BeanFactoryAware) this.advice).setBeanFactory(beanFactory);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Pointcut buildPointcut() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Pointcut cpc &#x3D; (Pointcut) new AnnotationMatchingPointcut(DataSource.class, true);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 类注解</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Pointcut clpc &#x3D; (Pointcut) AnnotationMatchingPointcut.forClassAnnotation(DataSource.class);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 方法注解</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Pointcut mpc &#x3D; (Pointcut) AnnotationMatchingPointcut.forMethodAnnotation(DataSource.class);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new ComposablePointcut(cpc).union(clpc).union(mpc);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="AbstractRoutingDataSource"><a href="#AbstractRoutingDataSource" class="headerlink" title="AbstractRoutingDataSource"></a>AbstractRoutingDataSource</h4><p>这个类是实现AOP动态数据源的关键，其作用就是动态切换数据源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class DynamicRoutingDataSource extends AbstractRoutingDataSource &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    protected Object determineCurrentLookupKey() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String dataSourceName &#x3D; DynamicDataSourceContextHolder.getDataSourceRouterKey();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.info(&quot;当前数据源是：&#123;&#125;&quot;, dataSourceName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return DynamicDataSourceContextHolder.getDataSourceRouterKey();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="在mapper层添加-DataSource自定义注解即可，不添加默认为master"><a href="#在mapper层添加-DataSource自定义注解即可，不添加默认为master" class="headerlink" title="在mapper层添加@DataSource自定义注解即可，不添加默认为master"></a>在mapper层添加@DataSource自定义注解即可，不添加默认为master</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@DataSource(&quot;assesssystem&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface UserMapper extends BaseMapper&lt;UserEntity&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;UserEntity&gt; listUser();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot多数据源——分包</title>
    <url>/2019/11/30/spring-boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E2%80%94%E2%80%94%E5%88%86%E5%8C%85/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>随着数据量的不断增多，单个数据库已经承受不了高并发带来的压力，此时使用多个数据库变得至关重要，传统项目整合多数据源有两种方案: AOP动态切换和分包配置数据源</p>
<h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;version&gt;2.1.6.RELEASE&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;version&gt;2.1.1&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;version&gt;1.2.54&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependencies&gt;</span></pre></td></tr></table></figure>

<h4 id="在application-yml中配置多个数据源"><a href="#在application-yml中配置多个数据源" class="headerlink" title="在application.yml中配置多个数据源"></a>在application.yml中配置多个数据源</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  datasource:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    master:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      driver-class-name: com.mysql.cj.jdbc.Driver</span></pre></td></tr><tr><td class="code"><pre><span class="line">      jdbc-url: jdbc:mysql:&#x2F;&#x2F;47.98.131.17:3306&#x2F;ruoyi1?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;useSSL&#x3D;true&amp;serverTimezone&#x3D;GMT%2B8</span></pre></td></tr><tr><td class="code"><pre><span class="line">      username: root</span></pre></td></tr><tr><td class="code"><pre><span class="line">      password: root</span></pre></td></tr><tr><td class="code"><pre><span class="line">    deputy:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      driver-class-name: com.mysql.cj.jdbc.Driver</span></pre></td></tr><tr><td class="code"><pre><span class="line">      jdbc-url: jdbc:mysql:&#x2F;&#x2F;47.98.131.17:3306&#x2F;ruoyi2?userUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;useSSL&#x3D;true&amp;serverTimezone&#x3D;GMT%2B8</span></pre></td></tr><tr><td class="code"><pre><span class="line">      username: root</span></pre></td></tr><tr><td class="code"><pre><span class="line">      password: root</span></pre></td></tr></table></figure>

<h4 id="编写MasterDataSourceConfig配置文件"><a href="#编写MasterDataSourceConfig配置文件" class="headerlink" title="编写MasterDataSourceConfig配置文件"></a>编写MasterDataSourceConfig配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@MapperScan(basePackages &#x3D; &#123;&quot;com.boyi.master.*.mapper&quot;&#125;, sqlSessionFactoryRef &#x3D; &quot;masterSqlSessionFactory&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class MasterDataSourceConfig &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 创建主数据源</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @return</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Primary &#x2F;&#x2F; 表示该数据源是默认数据源</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.master&quot;) &#x2F;&#x2F; 读取配置文件以prefix中开头的</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public DataSource masterDataSource() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return DataSourceBuilder.create().build();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Primary</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public SqlSessionFactory masterSqlSessionFactory() throws Exception&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 设置数据源</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sqlSessionFactoryBean.setDataSource(masterDataSource());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 获取mapper配置文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return sqlSessionFactoryBean.getObject();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 配置事务</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Primary</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public DataSourceTransactionManager masterTransactionManager() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new DataSourceTransactionManager(masterDataSource());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Primary</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public SqlSessionTemplate masterSqlSessionTemplate() throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new SqlSessionTemplate(masterSqlSessionFactory());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="编写副数据源配置文件"><a href="#编写副数据源配置文件" class="headerlink" title="编写副数据源配置文件"></a>编写副数据源配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@MapperScan(basePackages &#x3D; &#123;&quot;com.boyi.deputy.*.mapper&quot;&#125;,sqlSessionFactoryRef &#x3D; &quot;deputySqlSessionFactory&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class DeputyDataSourceConfig &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 创建副数据源</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @return</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.deputy&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public DataSource deputyDataSource() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return DataSourceBuilder.create().build();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public SqlSessionFactory deputySqlSessionFactory() throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sqlSessionFactoryBean.setDataSource(deputyDataSource());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return sqlSessionFactoryBean.getObject();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 配置事务</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Primary</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public DataSourceTransactionManager deputyTransactionManager() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new DataSourceTransactionManager(deputyDataSource());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Primary</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public SqlSessionTemplate deputySqlSessionTemplate() throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new SqlSessionTemplate(deputySqlSessionFactory());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="然后只要将不同数据库的操作分别放在对应的包下-basePackages-即可"><a href="#然后只要将不同数据库的操作分别放在对应的包下-basePackages-即可" class="headerlink" title="然后只要将不同数据库的操作分别放在对应的包下(basePackages)即可"></a>然后只要将不同数据库的操作分别放在对应的包下(basePackages)即可</h4><p>项目结构如下<br><img src="/2019/11/30/spring-boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E2%80%94%E2%80%94%E5%88%86%E5%8C%85/20191130221729.png" alt></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>配置文件中必须使用jdbc-url代替原来的url，否则会报jdbcUrl is required with driverClassName异常</li>
<li>若想ConfigurationProperties注解生效，必须导入spring-boot-configuration-processor包，否则不生效</li>
<li>事务的使用必须要指明是哪个数据源的事务管理器，否则事务失效，如@Transactional(value = “masterTransactionManager”)</li>
<li>如果一个方法涉及多个数据源操作，此时无法做到同时回滚，尽量避免这种操作，这里涉及分布式事务</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由上可见，分包方式实现多数据源有较大的局限性，尤其是事务的管理，下节将提供一种更推荐的方式来配置多数据源——AOP动态数据源</p>
]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>swagger使用指南</title>
    <url>/2019/11/29/swagger%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="什么是swgaaer"><a href="#什么是swgaaer" class="headerlink" title="什么是swgaaer"></a>什么是swgaaer</h2><p>swagger是一个功能简单但强大的API工具，可以非常友好的对外展示接口，以及接口文档的生成</p>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h4 id="maven配置依赖"><a href="#maven配置依赖" class="headerlink" title="maven配置依赖"></a>maven配置依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;version&gt;2.5.0&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;version&gt;2.5.0&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure>

<h4 id="编写swagger配置类"><a href="#编写swagger配置类" class="headerlink" title="编写swagger配置类"></a>编写swagger配置类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableSwagger2</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class SwaggerConfig &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 创建API应用</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * apiInfo() 增加API相关信息</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现，</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 本例采用指定扫描的包路径来定义指定要建立API的目录。</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @return</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Docket createRestApi() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .apiInfo(apiInfo())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#x2F;&#x2F; 选择那些路径和api会生成document</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .select()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#x2F;&#x2F; 扫描所有有注解的api，用这种方式更灵活</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#x2F;&#x2F;swagget扫描目录</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#x2F;&#x2F;.apis(RequestHandlerSelectors.basePackage(&quot;com.itcast.controller&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#x2F;&#x2F; 对所有路径进行监控</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .paths(PathSelectors.any())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .build();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 创建该API的基本信息（这些基本信息会展现在文档页面中）</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 访问地址：http:&#x2F;&#x2F;项目实际地址&#x2F;swagger-ui.html</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @return</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private ApiInfo apiInfo() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new ApiInfoBuilder()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .title(&quot;SpringBoot中使用Swagger2构建RESTful APIs&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .description(&quot;API 描述&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .termsOfServiceUrl(&quot;&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .version(&quot;1.0&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .build();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;$&#123;host&#125;:$&#123;port&#125;&#x2F;swagger-ui.html</span></pre></td></tr></table></figure>
<p><img src="/2019/11/29/swagger%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/swagger-ui.png" alt></p>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h4 id="Api-用于类，表示这个类是swagger资源"><a href="#Api-用于类，表示这个类是swagger资源" class="headerlink" title="Api 用于类，表示这个类是swagger资源"></a>Api 用于类，表示这个类是swagger资源</h4><ul>
<li>value 类说明</li>
<li>tags 类分组，同一个tags下的类会分在同一组</li>
</ul>
<h4 id="ApiOperation-用于方法"><a href="#ApiOperation-用于方法" class="headerlink" title="ApiOperation 用于方法"></a>ApiOperation 用于方法</h4><ul>
<li>value 方法描述</li>
<li>notes 提示内容</li>
</ul>
<h4 id="ApiParam-用于参数，方法，字段说明"><a href="#ApiParam-用于参数，方法，字段说明" class="headerlink" title="ApiParam 用于参数，方法，字段说明"></a>ApiParam 用于参数，方法，字段说明</h4><ul>
<li>name 参数名</li>
<li>value 参数说明</li>
<li>required 是否必填</li>
</ul>
<h4 id="ApiModel-用于实体类"><a href="#ApiModel-用于实体类" class="headerlink" title="ApiModel 用于实体类"></a>ApiModel 用于实体类</h4><ul>
<li>value 实体类名</li>
<li>description 描述</li>
</ul>
<h4 id="ApiModelProperty-字段"><a href="#ApiModelProperty-字段" class="headerlink" title="ApiModelProperty 字段"></a>ApiModelProperty 字段</h4><ul>
<li>value 字段说明</li>
<li>name 重写属性名称</li>
<li>dataType 重写属性类型</li>
<li>required 是否必填</li>
<li>example 举例说明</li>
<li>hidden 隐藏</li>
</ul>
<h4 id="ApiImplicitParams-用于方法，可以包含多个-ApiImplicitParam"><a href="#ApiImplicitParams-用于方法，可以包含多个-ApiImplicitParam" class="headerlink" title="ApiImplicitParams 用于方法，可以包含多个@ApiImplicitParam"></a>ApiImplicitParams 用于方法，可以包含多个@ApiImplicitParam</h4><ul>
<li>name 参数名称</li>
<li>value 参数说明</li>
<li>dataType 数据类型</li>
<li>paramType 参数类型</li>
<li>example 举例说明</li>
</ul>
<h2 id="生成接口文档"><a href="#生成接口文档" class="headerlink" title="生成接口文档"></a>生成接口文档</h2><h4 id="修改maven依赖"><a href="#修改maven依赖" class="headerlink" title="修改maven依赖"></a>修改maven依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;version&gt;2.5.0&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;com.github.xiaoymin&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;swagger-bootstrap-ui&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;version&gt;1.9.6&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure>

<h4 id="访问地址-1"><a href="#访问地址-1" class="headerlink" title="访问地址"></a>访问地址</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;$&#123;host&#125;:$&#123;port&#125;&#x2F;doc.html</span></pre></td></tr></table></figure>
<p><img src="/2019/11/29/swagger%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/swagger-bootstrap.png" alt></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
